##version: '3.8'
##services:
##  app:
##    build:
##      context: .
##      dockerfile: Dockerfile
##    container_name: canopy-app-prod
##    restart: unless-stopped
##    env_file:
##      - .env.production
##    environment:
##      - VIRTUAL_HOST=${DOMAIN:-85.198.102.69}
##      - VIRTUAL_PORT=3000
##      - LETSENCRYPT_HOST=${DOMAIN}
##      - LETSENCRYPT_EMAIL=${COMPANY_EMAIL:-admin@example.com}
##    expose:
##      - "3000"
##    depends_on:
##      postgres:
##        condition: service_healthy
##      redis:
##        condition: service_started
##    networks:
##      - npm-network
##    command: >
##      sh -c "
##        echo 'Waiting for PostgreSQL...' &&
##        until pg_isready -h postgres -p 5432 -U ${DATABASE_USERNAME:-admin}; do sleep 2; done &&
##        echo 'PostgreSQL ready!' &&
##        bundle exec rails db:prepare RAILS_ENV=production &&
##        bundle exec rails server -b 0.0.0.0 -p 3000 -e production
##      "
##    healthcheck:
##      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
##      interval: 30s
##      timeout: 10s
##      retries: 3
##
##  postgres:
##    image: postgres:16-alpine
##    container_name: canopy-postgres-prod
##    restart: unless-stopped
##    environment:
##      POSTGRES_USER: ${DATABASE_USERNAME:-admin}
##      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
##      POSTGRES_DB: ${DATABASE_NAME:-canopy_company_production}
##    volumes:
##      - postgres_data:/var/lib/postgresql/data
##    networks:
##      - npm-network
##    healthcheck:
##      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USERNAME:-admin}"]
##      interval: 10s
##      timeout: 5s
##      retries: 5
##
##  redis:
##    image: redis:7-alpine
##    container_name: canopy-redis-prod
##    restart: unless-stopped
##    command: redis-server --appendonly yes
##    volumes:
##      - redis_data:/data
##    networks:
##      - npm-network
##
##volumes:
##  postgres_data:
##  redis_data:
##
##networks:
##  npm-network:
##    external: true
##    name: npm-network
#
#
#version: '3.8'
#
#services:
#  app:
#    build:
#      context: .
#      dockerfile: Dockerfile # Рекомендуется отдельный Dockerfile для продакшена
#      args:
#        - RAILS_ENV=production
#        - NODE_ENV=production
#    container_name: canopy-app-prod
#    restart: unless-stopped
#    env_file:
#      - .env.production
#    environment:
#      # Nginx Proxy Manager интеграция
#      - VIRTUAL_HOST=${DOMAIN}
#      - VIRTUAL_PORT=3000
#      - LETSENCRYPT_HOST=${DOMAIN}
#      - LETSENCRYPT_EMAIL=${COMPANY_EMAIL}
#
#      # Rails оптимизации
#      - RAILS_ENV=production
#      - RAILS_SERVE_STATIC_FILES=true
#      - RAILS_LOG_TO_STDOUT=true
#      - RAILS_LOG_LEVEL=info
#      - RAILS_MAX_THREADS=${RAILS_MAX_THREADS:-5}
#      - WEB_CONCURRENCY=${WEB_CONCURRENCY:-2}
#
#      # Безопасность
#      - BUNDLE_DEPLOYMENT=true
#      - BUNDLE_WITHOUT=development:test
#      - BUNDLE_PATH=/usr/local/bundle
#
#      # Performance
#      - NODE_OPTIONS=--max-old-space-size=512
#      - RUBY_YJIT_ENABLE=1  # Включить JIT компилятор Ruby 3+
#
#      # Vite production
#      - NODE_ENV=production
#      - VITE_RUBY_HOST=${DOMAIN}
#      - VITE_RUBY_PORT=443
#    expose:
#      - "3000"
#    depends_on:
#      postgres:
#        condition: service_healthy
#      redis:
#        condition: service_started
#    networks:
#      - npm-network
#      - backend-network
#    command: >
#      sh -c "
#        echo '=== Production Startup ===' &&
#        echo 'Waiting for database...' &&
#        until pg_isready -h postgres -p 5432 -U ${DATABASE_USERNAME} -d ${DATABASE_NAME} >/dev/null 2>&1; do
#          sleep 2;
#        done &&
#        echo 'Database ready!' &&
#        echo 'Running migrations...' &&
#        bundle exec rails db:migrate RAILS_ENV=production &&
#        echo 'Starting Puma server...' &&
#        bundle exec puma -C config/puma.rb
#      "
#    healthcheck:
#      test: ["CMD", "curl", "-f", "http://localhost:3000/up"]
#      interval: 30s
#      timeout: 10s
#      retries: 3
#      start_period: 40s
#    deploy:
#      resources:
#        limits:
#          memory: 512M
#          cpus: '1.0'
#        reservations:
#          memory: 256M
#          cpus: '0.5'
#    volumes:
#      - app_logs:/app/log
#      - app_tmp:/app/tmp
#      - bundle_cache:/usr/local/bundle
#    logging:
#      driver: "json-file"
#      options:
#        max-size: "10m"
#        max-file: "5"
#        tag: "canopy-app"
#
#  postgres:
#    image: postgres:16-alpine
#    container_name: canopy-postgres-prod
#    restart: unless-stopped
#    environment:
#      POSTGRES_USER: ${DATABASE_USERNAME}
#      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
#      POSTGRES_DB: ${DATABASE_NAME}
#      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=C"
#      POSTGRES_HOST_AUTH_METHOD: scram-sha-256
#      PGDATA: /var/lib/postgresql/data/pgdata
#
#      # Оптимизация производительности
#      POSTGRES_SHARED_BUFFERS: 128MB
#      POSTGRES_EFFECTIVE_CACHE_SIZE: 1GB
#      POSTGRES_MAINTENANCE_WORK_MEM: 64MB
#      POSTGRES_CHECKPOINT_COMPLETION_TARGET: 0.9
#      POSTGRES_WAL_BUFFERS: 16MB
#      POSTGRES_DEFAULT_STATISTICS_TARGET: 100
#      POSTGRES_MAX_CONNECTIONS: 100
#    volumes:
#      - postgres_data:/var/lib/postgresql/data
#      - postgres_backup:/backups
#    networks:
#      - backend-network
#    healthcheck:
#      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USERNAME} -d ${DATABASE_NAME}"]
#      interval: 10s
#      timeout: 5s
#      retries: 5
#      start_period: 20s
#    deploy:
#      resources:
#        limits:
#          memory: 512M
#        reservations:
#          memory: 256M
#    command: >
#      postgres
#      -c shared_buffers=128MB
#      -c max_connections=100
#      -c effective_cache_size=1GB
#
#  redis:
#    image: redis:7-alpine
#    container_name: canopy-redis-prod
#    restart: unless-stopped
#    command: >
#      redis-server
#      --appendonly yes
#      --appendfsync everysec
#      --maxmemory 256mb
#      --maxmemory-policy allkeys-lru
#      --save 900 1
#      --save 300 10
#      --save 60 10000
#    volumes:
#      - redis_data:/data
#    networks:
#      - backend-network
#    healthcheck:
#      test: ["CMD", "redis-cli", "ping"]
#      interval: 10s
#      timeout: 3s
#      retries: 3
#    deploy:
#      resources:
#        limits:
#          memory: 256M
#        reservations:
#          memory: 128M
#
#  # Опционально: Sidekiq для фоновых задач
#  sidekiq:
#    build:
#      context: .
#      dockerfile: Dockerfile
#    container_name: canopy-sidekiq-prod
#    restart: unless-stopped
#    env_file:
#      - .env.production
#    depends_on:
#      - redis
#      - postgres
#    networks:
#      - backend-network
#    command: >
#      sh -c "
#        echo 'Starting Sidekiq...' &&
#        bundle exec sidekiq -C config/sidekiq.yml -e production
#      "
#    deploy:
#      resources:
#        limits:
#          memory: 256M
#        reservations:
#          memory: 128M
#    volumes:
#      - app_logs:/app/log
#      - app_tmp:/app/tmp
#      - bundle_cache:/usr/local/bundle
#    logging:
#      driver: "json-file"
#      options:
#        max-size: "10m"
#        max-file: "3"
#
#volumes:
#  postgres_data:
#    driver: local
#  redis_data:
#    driver: local
#  app_logs:
#    driver: local
#  app_tmp:
#    driver: local
#  bundle_cache:
#    driver: local
#  postgres_backup:
#    driver: local
#
#networks:
#  npm-network:
#    external: true
#    name: npm-network
#  backend-network:
#    driver: bridge
#    internal: false  # Разрешаем внешний доступ через npm-network



services:
  app:
    build:
      context: .
      dockerfile: Dockerfile  # Добавляем явное указание
    image: canopy-app-prod:latest
    container_name: canopy-app-prod
    restart: unless-stopped
    env_file:
      - .env.production
    ports:
      - "3000:3000"  # Исправляем expose на ports
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - canopy-network  # Переименовываем для ясности
      - npm-network
    command: >
      sh -c "
       echo 'Waiting for PostgreSQL...' &&
        sleep 15 &&
        echo 'Starting application...' &&
        bundle exec rails db:prepare &&
        bundle exec rails assets:precompile &&
        bundle exec rails server -b 0.0.0.0 -p 3000 -e production
      "
    volumes:
      - gems_data:/usr/local/bundle
      - ./log:/app/log  # Добавляем логи
      - ./tmp:/app/tmp  # Добавляем tmp
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/up"]
      interval: 30s
      timeout: 10s
      retries: 3

  postgres:
    image: postgres:16-alpine
    container_name: canopy-postgres-prod
    restart: unless-stopped
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin
      POSTGRES_DB: canopy_company_production
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - canopy-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: canopy-redis-prod
    restart: unless-stopped
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - canopy-network

volumes:
  postgres_data:
  redis_data:
  gems_data:

networks:
  canopy-network:
    driver: bridge
  npm-network:
    external: true
    name: npm-network